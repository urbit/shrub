# Axal guide

`+axal` is the recursive tree type that Shrubbery uses to build the namespace.

For userspace developers, axals are useful when you're writing `/con` files for your frontend and you want to work with the descendants of whichever shrub you're viewing in the frontend. (e.g. You're rendering a todo item and you want to render its sub-tasks, which are nodes beneath the main task in the namespace.)

We work with axals using the `+of` core defined in `/sur/neo.hoon`, whose arms are documented below.

[note on piths and paths, how `of:neo` is used and how to work with piths and paths, convert from path to pith, etc.]

The `+axal` type itself looks like this.

```
++  axal
  |$  [item]
  [fil=(unit item) kid=(map iota $)]
```

One way to think of the Shrubbery namespace is as a filesystem, where files could be data, code, or something in between. So the `+axal` represents a directory of such files. The `fil` is the state of the file, which may or may not be null. The `kid` map stores everything below this file in the directory. The map's keys are the path segments immediately below this layer of the directory, and its values are the subtrees that correspond to those paths.

***

## `+anc`

[??? - i see what this is doing just dk why]

```
++  anc
  =|  res=(list pith)
  =|  cur=pith
  |=  pax=pith
  ^-  (set pith)
  ?~  pax
    (~(gas in *(set pith)) res)
  =?  res  ?=(^ fil.fat)
    [cur res]
  $(fat (~(got by kid.fat) i.pax), pax t.pax, cur (snoc cur i.pax))
```

???

## `+anc-jab`

[??? - apply gate to nodes?]

```
++  anc-jab
  |*  [pax=pith fun=$-(* *)]
  ^+  fat
  ?~  pax
    fat
  =?  fil.fat  ?=(^ fil.fat)
    `(fun u.fil.fat)
  fat(kid (~(put by kid.fat) i.pax $(fat (~(got by kid.fat) i.pax), pax t.pax)))
```

???

## `+del`

Delete a node.

```
++  del
  |=  pax=pith
  ^+  fat
  ?~  pax  [~ kid.fat]
  =/  kid  (~(get by kid.fat) i.pax)
  ?~  kid  fat
  fat(kid (~(put by kid.fat) i.pax $(fat u.kid, pax t.pax)))
```

Returns an axal with the node at path `pax` removed.

## `+dip`

Descend to the axal at this path, [which does what]

```
++  dip
  |=  pax=pith
  ^+  fat
  ?~  pax  fat
  =/  kid  (~(get by kid.fat) i.pax)
  ?~  kid  [~ ~]
  $(fat u.kid, pax t.pax)
```

Returns an axal whose uppermost node is the node at the given path `pax`.

## `+fit`

Fetch file at the longest existing prefix of this path.

```
++  fit
  |=  pax=pith
  ^+  [pax fil.fat]
  ?~  pax  [~ fil.fat]
  =/  kid  (~(get by kid.fat) i.pax)
  ?~  kid  [pax fil.fat]
  =/  low  $(fat u.kid, pax t.pax)
  ?~  +.low
    [pax fil.fat]
  low
```

Returns a `(pair pith *)` where `*` is the node at the given path `pax`.

## `+gas`

Merge a list of `(pair pith *)` with the axal.

[??? that's what it looks like this should do but i'd expect a `|-` in here]

```
++  gas
  |*  lit=(list (pair pith _?>(?=(^ fil.fat) u.fil.fat)))
  ^+  fat
  ?~  lit  fat
  $(fat (put p.i.lit q.i.lit), lit t.lit)
```

Returns an axal.

## `+get`

Get a node.

```
++  get
  |=  pax=pith
  fil:(dip pax)
```

Returns a unit of the node.

## `+got`

Get a node, error if the node doesn't exist.

```
++  got
  |=  pax=pith
  ~|  missing-room/pax
  (need (get pax))
```

Returns the node or errors.

## `+gut`

Get a node, with a default to fall back on.

```
++  gut
  |*  [pax=pith dat=*]
  =>  .(dat `_?>(?=(^ fil.fat) u.fil.fat)`dat, pax `pith`pax)
  ^+  dat
  (fall (get pax) dat)
```

Returns the node if it exists, return the default noun `dat` if not.

## `+has`

Check if the axal contains a node as this path.

```
++  has
  |=  pax=pith
  !=(~ (get pax))
```

Returns `%.y` if the node exists, `%.n` if not.

## `+kid`

???

```
++  kid
  |=  pax=pith
  ^-  (map pith _?>(?=(^ fil.fat) u.fil.fat))
  =.  fat  (dip pax)
  =.  fat  snip
  =.  fil.fat  ~
  tar
```

Returns a `(map pith *)` where `*` is the type of the node in the sample axal.

## `+kids`

Get the kids of the node at the given path.

```
++  kids
  |=  pax=pith
  ^-  (axil _?>(?=(^ fil.fat) u.fil.fat))
  :-  (get pax)
  (kid pax)
```

Returns an [`axil`](https://docs.urbit.org/language/hoon/reference/arvo#axil).

[why an axil? not sure what the different usage is in this case]

## `+lop`

Recursively remove nodes from the tree. [??? - need to play around with this but i think the idea is that if given path /foo/bar/baz it will remove the nodes at addresses /foo, /bar, and /baz]

```
++  lop
  |=  pax=pith
  ^+  fat
  ?~  pax  fat
  |-
  ?~  t.pax  fat(kid (~(del by kid.fat) i.pax))
  =/  kid  (~(get by kid.fat) i.pax)
  ?~  kid  fat
  fat(kid (~(put by kid.fat) i.pax $(fat u.kid, pax t.pax)))
```

Returns an axal.

## `+parent`

???

```
++  parent
  =|  res=(unit pith)
  =|  cur=pith
  |=  pax=pith
  |-  ^+  res
  ?~  pax
    res
  =?  res  ?=(^ fil.fat)
    `cur
  =/  nex  (~(get by kid.fat) i.pax)
  ?~  nex
    res
  $(fat u.nex, pax t.pax, cur (snoc cur i.pax))
```

Returns a `(unit pith)`.

## `+put`

Add a node to the axal.

```
++  put
  |*  [pax=pith dat=*]
  ^+  fat
  =>  .(dat `_?>(?=(^ fil.fat) u.fil.fat)`dat, pax `pith`pax)
  |-  ^+  fat
  ?~  pax  fat(fil `dat)
  =/  kid  (~(gut by kid.fat) i.pax ^+(fat [~ ~]))
  fat(kid (~(put by kid.fat) i.pax $(fat kid, pax t.pax)))
```

Returns an axal with the given node `dat` added at the given path `pax`.

## `+snip`

Prune empty nodes from the descendants of this node.

```
++  snip
  |-  ^+  fat
  =*  loop  $
  %_    fat
      kid
    %-  ~(run by kid.fat)
    |=  f=_fat
    ?^  fil.f
      [`u.fil.f ~]
    loop(fat f)
  ==
```

Returns an `axal`.

## `+tap`

Flatten the axal into a list.

```
++  tap
  =|  pax=pith
  =|  out=(list (pair pith _?>(?=(^ fil.fat) u.fil.fat)))
  |-  ^+   out
  =?  out  ?=(^ fil.fat)  :_(out [pax u.fil.fat])
  =/  kid  ~(tap by kid.fat)
  |-  ^+   out
  ?~  kid  out
  %=  $
    kid  t.kid
    out  ^$(pax (weld pax /[p.i.kid]), fat q.i.kid)
  ==
```

Returns a `(list (pair pith *))` where `*` is the type of the nodes in the axal given as the `+of` door's sample.

## `+tar`

Flatten the axal into a map.

```
++  tar
  (~(gas by *(map pith _?>(?=(^ fil.fat) u.fil.fat))) tap)
--
```

Returns a `(map pith *)` where `*` is the type of the node in the axal given as the `+of` door's sample.

## `+view`

View a subtree of the sample axal.

```
++  view
  =|  res=(map pith _?>(?=(^ fil.fat) u.fil.fat))
  |=  [=care pax=pith]
  =.  fat  (dip pax)
  =?  res  ?=(^ fil.fat)
   (~(put by res) ~ u.fil.fat)
  ?+  care  !!
    %x  res
    %y  =.(fat snip (~(uni by res) tar))
    %z  (~(uni by res) tar)
  ==
```

Returns a subtree of the sample axal. Depending on the given care this subtree will be the node at the given path, the node and its immediate children, or the entire subtree below the node at the given path.

